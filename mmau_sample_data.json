[
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nThis version of the problem differs from the next one only in the constraint on n.\n\nNote that the memory limit in this problem is lower than in others.\n\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\n\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\n\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \n\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \n\n\n\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\n\nInput\n\nThe only line contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\n\nOutput\n\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\n\nExamples\n\nInput\n\n\n3 998244353\n\n\nOutput\n\n\n5\n\n\nInput\n\n\n5 998244353\n\n\nOutput\n\n\n25\n\n\nInput\n\n\n42 998244353\n\n\nOutput\n\n\n793019428\n\nNote\n\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\n\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\n\nTherefore, there are five ways in total.\n\n#GENERATED PLAN#:\n",
    "output": [
      "25",
      "793019428",
      "5"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nn people gathered to hold a jury meeting of the upcoming competition, the i-th member of the jury came up with a_i tasks, which they want to share with each other.\n\nFirst, the jury decides on the order which they will follow while describing the tasks. Let that be a permutation p of numbers from 1 to n (an array of size n where each integer from 1 to n occurs exactly once).\n\nThen the discussion goes as follows:\n\n  * If a jury member p_1 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \n  * If a jury member p_2 has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \n  * ... \n  * If a jury member p_n has some tasks left to tell, then they tell one task to others. Otherwise, they are skipped. \n  * If there are still members with tasks left, then the process repeats from the start. Otherwise, the discussion ends. \n\n\n\nA permutation p is nice if none of the jury members tell two or more of their own tasks in a row. \n\nCount the number of nice permutations. The answer may be really large, so print it modulo 998 244 353.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of the test case contains a single integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 number of jury members.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9) \u2014 the number of problems that the i-th member of the jury came up with.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the number of nice permutations, taken modulo 998 244 353.\n\nExample\n\nInput\n\n\n4\n2\n1 2\n3\n5 5 5\n4\n1 3 3 7\n6\n3 4 2 1 3 3\n\n\nOutput\n\n\n1\n6\n0\n540\n\nNote\n\nExplanation of the first test case from the example:\n\nThere are two possible permutations, p = [1, 2] and p = [2, 1]. For p = [1, 2], the process is the following:\n\n  1. the first jury member tells a task; \n  2. the second jury member tells a task; \n  3. the first jury member doesn't have any tasks left to tell, so they are skipped; \n  4. the second jury member tells a task. \n\n\n\nSo, the second jury member has told two tasks in a row (in succession), so the permutation is not nice.\n\nFor p = [2, 1], the process is the following:\n\n  1. the second jury member tells a task; \n  2. the first jury member tells a task; \n  3. the second jury member tells a task. \n\n\n\nSo, this permutation is nice.\n\n#GENERATED PLAN#:\n",
    "output": [
      "1\n6\n0\n540\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nThis is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n5\n0 0\n2 16\n30 14\n4 6\n2 10\n\n\nOutput\n\n\n3\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 3 interesting fences. \n\n  * (0,0) \u2014 (30,14) \u2014 (2,10) \n  * (2,16) \u2014 (30,14) \u2014 (2,10) \n  * (30,14) \u2014 (4,6) \u2014 (2,10) \n\n#GENERATED PLAN#:\n",
    "output": [
      "3\n",
      "1\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nYou are given a 1 by n pixel image. The i-th pixel of the image has color a_i. For each color, the number of pixels of that color is at most 20.\n\nYou can perform the following operation, which works like the bucket tool in paint programs, on this image: \n\n  * pick a color \u2014 an integer from 1 to n; \n  * choose a pixel in the image; \n  * for all pixels connected to the selected pixel, change their colors to the selected color (two pixels of the same color are considered connected if all the pixels between them have the same color as those two pixels). \n\n\n\nCompute the minimum number of operations needed to make all the pixels in the image have the same color.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^3).\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 3\u22c510^3) \u2014 the number of pixels in the image.\n\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n) \u2014 the colors of the pixels in the image.\n\nNote: for each color, the number of pixels of that color is at most 20.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c510^3.\n\nOutput\n\nFor each test case, print one integer: the minimum number of operations needed to make all the pixels in the image have the same color.\n\nExample\n\nInput\n\n\n3\n5\n1 2 3 2 1\n4\n1 1 2 2\n5\n1 2 1 4 2\n\n\nOutput\n\n\n2\n1\n3\n\nNote\n\nIn the first example, the optimal solution is to apply the operation on the third pixel changing its color to 2 and then to apply the operation on any pixel that has color 2 changing its color and the color of all pixels connected to it to 1. The sequence of operations is then: [1, 2, 3, 2, 1] \u2192 [1, 2, 2, 2, 1] \u2192 [1, 1, 1, 1, 1].\n\nIn the second example, we can either change the 1s to 2s in one operation or change the 2s to 1s also in one operation.\n\nIn the third example, one possible way to make all the pixels have the same color is to apply the operation on the first, third and the fourth pixel each time changing its color to 2.\n\n#GENERATED PLAN#:\n",
    "output": [
      "2\n1\n3\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nThis is the hard version of the problem. The only difference from the easy version is that in this version the coordinates can be both odd and even.\n\nThere are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.\n\nThere are an infinite number of cows on the plane, one at every point with integer coordinates.\n\nGregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.\n\nFind the number of interesting fences.\n\nInput\n\nThe first line contains the integer n (3 \u2264 n \u2264 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.\n\nEach of the next n line contains two integers x and y (0 \u2264 x,y \u2264 10^7, where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.\n\nOutput\n\nPrint a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.\n\nExamples\n\nInput\n\n\n3\n0 0\n2 0\n0 4\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n4\n1 8\n0 6\n5 2\n5 6\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n10\n170 59\n129 54\n5 98\n129 37\n58 193\n154 58\n24 3\n13 138\n136 144\n174 150\n\n\nOutput\n\n\n29\n\nNote\n\nIn the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.\n\n<image>\n\nIn the second example, there are 4 possible fences. Only one of them is interesting however. That fence has an area of 8 and 5 enclosed cows.\n\n<image>\n\n#GENERATED PLAN#:\n",
    "output": [
      "29\n",
      "1\n",
      "1\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nPolycarp doesn't like integers that are divisible by 3 or end with the digit 3 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.\n\nPolycarp starts to write out the positive (greater than 0) integers which he likes: 1, 2, 4, 5, 7, 8, 10, 11, 14, 16, .... Output the k-th element of this sequence (the elements are numbered from 1).\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. Then t test cases follow.\n\nEach test case consists of one line containing one integer k (1 \u2264 k \u2264 1000).\n\nOutput\n\nFor each test case, output in a separate line one integer x \u2014 the k-th element of the sequence that was written out by Polycarp.\n\nExample\n\nInput\n\n\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n1000\n\n\nOutput\n\n\n1\n2\n4\n5\n7\n8\n10\n11\n14\n1666\n\n#GENERATED PLAN#:\n",
    "output": [
      "1\n2\n4\n5\n7\n8\n10\n11\n14\n1666\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nNote that the memory limit in this problem is lower than in others.\n\nYou have a vertical strip with n cells, numbered consecutively from 1 to n from top to bottom.\n\nYou also have a token that is initially placed in cell n. You will move the token up until it arrives at cell 1.\n\nLet the token be in cell x > 1 at some moment. One shift of the token can have either of the following kinds: \n\n  * Subtraction: you choose an integer y between 1 and x-1, inclusive, and move the token from cell x to cell x - y. \n  * Floored division: you choose an integer z between 2 and x, inclusive, and move the token from cell x to cell \u230a x/z \u230b (x divided by z rounded down). \n\n\n\nFind the number of ways to move the token from cell n to cell 1 using one or more shifts, and print it modulo m. Note that if there are several ways to move the token from one cell to another in one shift, all these ways are considered distinct (check example explanation for a better understanding).\n\nInput\n\nThe only line contains two integers n and m (2 \u2264 n \u2264 4 \u22c5 10^6; 10^8 < m < 10^9; m is a prime number) \u2014 the length of the strip and the modulo.\n\nOutput\n\nPrint the number of ways to move the token from cell n to cell 1, modulo m.\n\nExamples\n\nInput\n\n\n3 998244353\n\n\nOutput\n\n\n5\n\n\nInput\n\n\n5 998244353\n\n\nOutput\n\n\n25\n\n\nInput\n\n\n42 998244353\n\n\nOutput\n\n\n793019428\n\n\nInput\n\n\n787788 100000007\n\n\nOutput\n\n\n94810539\n\nNote\n\nIn the first test, there are three ways to move the token from cell 3 to cell 1 in one shift: using subtraction of y = 2, or using division by z = 2 or z = 3.\n\nThere are also two ways to move the token from cell 3 to cell 1 via cell 2: first subtract y = 1, and then either subtract y = 1 again or divide by z = 2.\n\nTherefore, there are five ways in total.\n\n#GENERATED PLAN#:\n",
    "output": [
      "5",
      "793019428",
      "94810539",
      "25"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nTwo painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n \u00d7 m grid.\n\nFor each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.\n\nGregor considers the cell (i,j) to be badly painted if a_i+b_j \u2264 x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.\n\nGregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.\n\nInput\n\nThe first line contains three integers n, m and x (1 \u2264 n,m \u2264 2\u22c5 10^5, 1 \u2264 x \u2264 2\u22c5 10^5) \u2014 the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 2\u22c5 10^5), the number of paint layers Amin applies to each row.\n\nThe third line contains m integers b_1, b_2, \u2026, b_m (1 \u2264 b_j \u2264 2\u22c5 10^5), the number of paint layers Benj applies to each column.\n\nOutput\n\nPrint a single integer, the number of badly painted regions.\n\nExamples\n\nInput\n\n\n3 4 11\n9 8 5\n10 6 7 2\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n3 4 12\n9 8 5\n10 6 7 2\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n3 3 2\n1 2 1\n1 2 1\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n5 23 6\n1 4 3 5 2\n2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5\n\n\nOutput\n\n\n6\n\nNote\n\nThe diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.\n\nThe colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.\n\n<image>\n\n#GENERATED PLAN#:\n",
    "output": [
      "1\n",
      "2\n",
      "6\n",
      "4\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nIt is a simplified version of problem F2. The difference between them is the constraints (F1: k \u2264 2, F2: k \u2264 10).\n\nYou are given an integer n. Find the minimum integer x such that x \u2265 n and the number x is k-beautiful.\n\nA number is called k-beautiful if its decimal representation having no leading zeroes contains no more than k different digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21 are k-beautiful whereas the numbers 120, 445435 and 998244353 are not.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\n\nEach test case consists of one line containing two integers n and k (1 \u2264 n \u2264 10^9, 1 \u2264 k \u2264 2).\n\nOutput\n\nFor each test case output on a separate line x \u2014 the minimum k-beautiful integer such that x \u2265 n.\n\nExample\n\nInput\n\n\n4\n1 1\n221 2\n177890 2\n998244353 1\n\n\nOutput\n\n\n1\n221\n181111\n999999999\n\n#GENERATED PLAN#:\n",
    "output": [
      "1\n221\n181111\n999999999\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nYou are given a simple undirected graph with n vertices, n is even. You are going to write a letter on each vertex. Each letter should be one of the first k letters of the Latin alphabet.\n\nA path in the graph is called Hamiltonian if it visits each vertex exactly once. A string is called palindromic if it reads the same from left to right and from right to left. A path in the graph is called palindromic if the letters on the vertices in it spell a palindromic string without changing the order.\n\nA string of length n is good if: \n\n  * each letter is one of the first k lowercase Latin letters; \n  * if you write the i-th letter of the string on the i-th vertex of the graph, there will exist a palindromic Hamiltonian path in the graph. \n\n\n\nNote that the path doesn't necesserily go through the vertices in order 1, 2, ..., n.\n\nCount the number of good strings.\n\nInput\n\nThe first line contains three integers n, m and k (2 \u2264 n \u2264 12; n is even; 0 \u2264 m \u2264 (n \u22c5 (n-1))/(2); 1 \u2264 k \u2264 12) \u2014 the number of vertices in the graph, the number of edges in the graph and the number of first letters of the Latin alphabet that can be used.\n\nEach of the next m lines contains two integers v and u (1 \u2264 v, u \u2264 n; v \u2260 u) \u2014 the edges of the graph. The graph doesn't contain multiple edges and self-loops.\n\nOutput\n\nPrint a single integer \u2014 number of good strings.\n\nExamples\n\nInput\n\n\n4 3 3\n1 2\n2 3\n3 4\n\n\nOutput\n\n\n9\n\n\nInput\n\n\n4 6 3\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n\n\nOutput\n\n\n21\n\n\nInput\n\n\n12 19 12\n1 3\n2 6\n3 6\n3 7\n4 8\n8 5\n8 7\n9 4\n5 9\n10 1\n10 4\n10 6\n9 10\n11 1\n5 11\n7 11\n12 2\n12 5\n12 11\n\n\nOutput\n\n\n456165084\n\n#GENERATED PLAN#:\n",
    "output": [
      "21\n",
      "9\n",
      "                                                       456165084"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nA tree is an undirected connected graph without cycles.\n\nYou are given a tree of n vertices. Find the number of ways to choose exactly k vertices in this tree (i. e. a k-element subset of vertices) so that all pairwise distances between the selected vertices are equal (in other words, there exists an integer c such that for all u, v (u \u2260 v, u, v are in selected vertices) d_{u,v}=c, where d_{u,v} is the distance from u to v).\n\nSince the answer may be very large, you need to output it modulo 10^9 + 7.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\n\nEach test case is preceded by an empty line.\n\nEach test case consists of several lines. The first line of the test case contains two integers n and k (2 \u2264 k \u2264 n \u2264 100) \u2014 the number of vertices in the tree and the number of vertices to be selected, respectively. Then n - 1 lines follow, each of them contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) which describe a pair of vertices connected by an edge. It is guaranteed that the given graph is a tree and has no loops or multiple edges.\n\nOutput\n\nFor each test case output in a separate line a single integer \u2014 the number of ways to select exactly k vertices so that for all pairs of selected vertices the distances between the vertices in the pairs are equal, modulo 10^9 + 7 (in other words, print the remainder when divided by 1000000007).\n\nExample\n\nInput\n\n\n3\n\n4 2\n1 2\n2 3\n2 4\n\n3 3\n1 2\n2 3\n\n5 3\n1 2\n2 3\n2 4\n4 5\n\n\nOutput\n\n\n6\n0\n1\n\n#GENERATED PLAN#:\n",
    "output": [
      "6\n0\n1\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nThis is the easy version of the problem. The only difference between the two versions is the constraint on n. You can make hacks only if all versions of the problem are solved.\n\nA forest is an undirected graph without cycles (not necessarily connected).\n\nMocha and Diana are friends in Zhijiang, both of them have a forest with nodes numbered from 1 to n, and they would like to add edges to their forests such that: \n\n  * After adding edges, both of their graphs are still forests. \n  * They add the same edges. That is, if an edge (u, v) is added to Mocha's forest, then an edge (u, v) is added to Diana's forest, and vice versa. \n\n\n\nMocha and Diana want to know the maximum number of edges they can add, and which edges to add.\n\nInput\n\nThe first line contains three integers n, m_1 and m_2 (1 \u2264 n \u2264 1000, 0 \u2264 m_1, m_2 < n) \u2014 the number of nodes and the number of initial edges in Mocha's forest and Diana's forest.\n\nEach of the next m_1 lines contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) \u2014 the edges in Mocha's forest.\n\nEach of the next m_2 lines contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) \u2014 the edges in Diana's forest.\n\nOutput\n\nThe first line contains only one integer h, the maximum number of edges Mocha and Diana can add (in each forest).\n\nEach of the next h lines contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) \u2014 the edge you add each time.\n\nIf there are multiple correct answers, you can print any one of them.\n\nExamples\n\nInput\n\n\n3 2 2\n1 2\n2 3\n1 2\n1 3\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n5 3 2\n5 4\n2 1\n4 3\n4 3\n1 4\n\n\nOutput\n\n\n1\n2 4\n\n\nInput\n\n\n8 1 2\n1 7\n2 6\n1 5\n\n\nOutput\n\n\n5\n5 2\n2 3\n3 4\n4 7\n6 8\n\nNote\n\nIn the first example, we cannot add any edge.\n\nIn the second example, the initial forests are as follows.\n\n<image>\n\nWe can add an edge (2, 4).\n\n<image>\n\n#GENERATED PLAN#:\n",
    "output": [
      "5\n1 2\n1 3\n1 4\n1 8\n5 7\n",
      "1\n1 5\n",
      "0\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nGregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.\n\nGregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.\n\n  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and \n  * 2 \u2264 a < b \u2264 P. \n\n\n\nHelp Gregor find two bases of his favorite prime number!\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 1000).\n\nEach subsequent line contains the integer P (5 \u2264 P \u2264 {10}^9), with P guaranteed to be prime.\n\nOutput\n\nYour output should consist of t lines. Each line should consist of two integers a and b (2 \u2264 a < b \u2264 P). If there are multiple possible solutions, print any.\n\nExample\n\nInput\n\n\n2\n17\n5\n\n\nOutput\n\n\n3 5\n2 4\n\nNote\n\nThe first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.\n\nIn the second query, with P=5, the only solution is a=2 and b=4.\n\n#GENERATED PLAN#:\n",
    "output": [
      "2 16\n2 4\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nMoamen and Ezzat are playing a game. They create an array a of n non-negative integers where every element is less than 2^k.\n\nMoamen wins if a_1  \\&  a_2  \\&  a_3  \\&  \u2026  \\&  a_n \u2265 a_1 \u2295 a_2 \u2295 a_3 \u2295 \u2026 \u2295 a_n.\n\nHere \\& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND), and \u2295 denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nPlease calculate the number of winning for Moamen arrays a.\n\nAs the result may be very large, print the value modulo 1 000 000 007 (10^9 + 7).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 5)\u2014 the number of test cases. \n\nEach test case consists of one line containing two integers n and k (1 \u2264 n\u2264 2\u22c5 10^5, 0 \u2264 k \u2264 2\u22c5 10^5).\n\nOutput\n\nFor each test case, print a single value \u2014 the number of different arrays that Moamen wins with.\n\nPrint the result modulo 1 000 000 007 (10^9 + 7).\n\nExample\n\nInput\n\n\n3\n3 1\n2 1\n4 0\n\n\nOutput\n\n\n5\n2\n1\n\nNote\n\nIn the first example, n = 3, k = 1. As a result, all the possible arrays are [0,0,0], [0,0,1], [0,1,0], [1,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\n\nMoamen wins in only 5 of them: [0,0,0], [1,1,0], [0,1,1], [1,0,1], and [1,1,1].\n\n#GENERATED PLAN#:\n",
    "output": [
      "5\n2\n1\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nMorning desert sun horizon\n\nRise above the sands of time...\n\nFates Warning, \"Exodus\"\n\nAfter crossing the Windswept Wastes, Ori has finally reached the Windtorn Ruins to find the Heart of the Forest! However, the ancient repository containing this priceless Willow light did not want to open!\n\nOri was taken aback, but the Voice of the Forest explained to him that the cunning Gorleks had decided to add protection to the repository.\n\nThe Gorleks were very fond of the \"string expansion\" operation. They were also very fond of increasing subsequences.\n\nSuppose a string s_1s_2s_3 \u2026 s_n is given. Then its \"expansion\" is defined as the sequence of strings s_1, s_1 s_2, ..., s_1 s_2 \u2026 s_n, s_2, s_2 s_3, ..., s_2 s_3 \u2026 s_n, s_3, s_3 s_4, ..., s_{n-1} s_n, s_n. For example, the \"expansion\" the string 'abcd' will be the following sequence of strings: 'a', 'ab', 'abc', 'abcd', 'b', 'bc', 'bcd', 'c', 'cd', 'd'. \n\nTo open the ancient repository, Ori must find the size of the largest increasing subsequence of the \"expansion\" of the string s. Here, strings are compared lexicographically.\n\nHelp Ori with this task!\n\nA string a is lexicographically smaller than a string b if and only if one of the following holds:\n\n  * a is a prefix of b, but a \u2260 b;\n  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\n\nInput\n\nEach test contains multiple test cases.\n\nThe first line contains one positive integer t (1 \u2264 t \u2264 10^3), denoting the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains one positive integer n (1 \u2264 n \u2264 5000) \u2014 length of the string.\n\nThe second line of each test case contains a non-empty string of length n, which consists of lowercase latin letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\n\nOutput\n\nFor every test case print one non-negative integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n7\n5\nacbac\n8\nacabacba\n12\naaaaaaaaaaaa\n10\nabacabadac\n8\ndcbaabcd\n3\ncba\n6\nsparky\n\n\nOutput\n\n\n9\n17\n12\n29\n14\n3\n9\n\nNote\n\nIn first test case the \"expansion\" of the string is: 'a', 'ac', 'acb', 'acba', 'acbac', 'c', 'cb', 'cba', 'cbac', 'b', 'ba', 'bac', 'a', 'ac', 'c'. The answer can be, for example, 'a', 'ac', 'acb', 'acba', 'acbac', 'b', 'ba', 'bac', 'c'.\n\n#GENERATED PLAN#:\n",
    "output": [
      "9\n17\n12\n29\n14\n3\n9\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nPizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of 6 slices, medium ones consist of 8 slices, and large pizzas consist of 10 slices each. Baking them takes 15, 20 and 25 minutes, respectively.\n\nPetya's birthday is today, and n of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.\n\nYour task is to determine the minimum number of minutes that is needed to make pizzas containing at least n slices in total. For example: \n\n  * if 12 friends come to Petya's birthday, he has to order pizzas containing at least 12 slices in total. He can order two small pizzas, containing exactly 12 slices, and the time to bake them is 30 minutes; \n  * if 15 friends come to Petya's birthday, he has to order pizzas containing at least 15 slices in total. He can order a small pizza and a large pizza, containing 16 slices, and the time to bake them is 40 minutes; \n  * if 300 friends come to Petya's birthday, he has to order pizzas containing at least 300 slices in total. He can order 15 small pizzas, 10 medium pizzas and 13 large pizzas, in total they contain 15 \u22c5 6 + 10 \u22c5 8 + 13 \u22c5 10 = 300 slices, and the total time to bake them is 15 \u22c5 15 + 10 \u22c5 20 + 13 \u22c5 25 = 750 minutes; \n  * if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is 15 minutes. \n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nEach testcase consists of a single line that contains a single integer n (1 \u2264 n \u2264 10^{16}) \u2014 the number of Petya's friends.\n\nOutput\n\nFor each testcase, print one integer \u2014 the minimum number of minutes that is needed to bake pizzas containing at least n slices in total.\n\nExample\n\nInput\n\n\n6\n12\n15\n300\n1\n9999999999999999\n3\n\n\nOutput\n\n\n30\n40\n750\n15\n25000000000000000\n15\n\n#GENERATED PLAN#:\n",
    "output": [
      "30\n40\n750\n15\n25000000000000000\n15\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nThe Olympic Games have just started and Federico is eager to watch the marathon race.\n\nThere will be n athletes, numbered from 1 to n, competing in the marathon, and all of them have taken part in 5 important marathons, numbered from 1 to 5, in the past. For each 1\u2264 i\u2264 n and 1\u2264 j\u2264 5, Federico remembers that athlete i ranked r_{i,j}-th in marathon j (e.g., r_{2,4}=3 means that athlete 2 was third in marathon 4).\n\nFederico considers athlete x superior to athlete y if athlete x ranked better than athlete y in at least 3 past marathons, i.e., r_{x,j}<r_{y,j} for at least 3 distinct values of j.\n\nFederico believes that an athlete is likely to get the gold medal at the Olympics if he is superior to all other athletes.\n\nFind any athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes), or determine that there is no such athlete.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t test cases follow.\n\nThe first line of each test case contains a single integer n (1\u2264 n\u2264 50 000) \u2014 the number of athletes.\n\nThen n lines follow, each describing the ranking positions of one athlete.\n\nThe i-th of these lines contains the 5 integers r_{i,1},\\,r_{i,2},\\,r_{i,3},\\,r_{i,4},  r_{i,5} (1\u2264 r_{i,j}\u2264 50 000) \u2014 the ranking positions of athlete i in the past 5 marathons. It is guaranteed that, in each of the 5 past marathons, the n athletes have distinct ranking positions, i.e., for each 1\u2264 j\u2264 5, the n values r_{1,j},  r_{2, j},  ...,  r_{n, j} are distinct.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 50 000.\n\nOutput\n\nFor each test case, print a single integer \u2014 the number of an athlete who is likely to get the gold medal (that is, an athlete who is superior to all other athletes). If there are no such athletes, print -1. If there is more than such one athlete, print any of them.\n\nExample\n\nInput\n\n\n4\n1\n50000 1 50000 50000 50000\n3\n10 10 20 30 30\n20 20 30 10 10\n30 30 10 20 20\n3\n1 1 1 1 1\n2 2 2 2 2\n3 3 3 3 3\n6\n9 5 3 7 1\n7 4 1 6 8\n5 6 7 3 2\n6 7 8 8 6\n4 2 2 4 5\n8 3 6 9 4\n\n\nOutput\n\n\n1\n-1\n1\n5\n\nNote\n\nExplanation of the first test case: There is only one athlete, therefore he is superior to everyone else (since there is no one else), and thus he is likely to get the gold medal.\n\nExplanation of the second test case: There are n=3 athletes. \n\n  * Athlete 1 is superior to athlete 2. Indeed athlete 1 ranks better than athlete 2 in the marathons 1, 2 and 3. \n  * Athlete 2 is superior to athlete 3. Indeed athlete 2 ranks better than athlete 3 in the marathons 1, 2, 4 and 5. \n  * Athlete 3 is superior to athlete 1. Indeed athlete 3 ranks better than athlete 1 in the marathons 3, 4 and 5. \n\n\n\nExplanation of the third test case: There are n=3 athletes. \n\n  * Athlete 1 is superior to athletes 2 and 3. Since he is superior to all other athletes, he is likely to get the gold medal. \n  * Athlete 2 is superior to athlete 3. \n  * Athlete 3 is not superior to any other athlete. \n\n\n\nExplanation of the fourth test case: There are n=6 athletes. \n\n  * Athlete 1 is superior to athletes 3, 4, 6. \n  * Athlete 2 is superior to athletes 1, 4, 6. \n  * Athlete 3 is superior to athletes 2, 4, 6. \n  * Athlete 4 is not superior to any other athlete. \n  * Athlete 5 is superior to athletes 1, 2, 3, 4, 6. Since he is superior to all other athletes, he is likely to get the gold medal. \n  * Athlete 6 is only superior to athlete 4. \n\n#GENERATED PLAN#:\n",
    "output": [
      "1\n-1\n1\n5\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nAn ant moves on the real line with constant speed of 1 unit per second. It starts at 0 and always moves to the right (so its position increases by 1 each second).\n\nThere are n portals, the i-th of which is located at position x_i and teleports to position y_i < x_i. Each portal can be either active or inactive. The initial state of the i-th portal is determined by s_i: if s_i=0 then the i-th portal is initially inactive, if s_i=1 then the i-th portal is initially active. When the ant travels through a portal (i.e., when its position coincides with the position of a portal): \n\n  * if the portal is inactive, it becomes active (in this case the path of the ant is not affected); \n  * if the portal is active, it becomes inactive and the ant is instantly teleported to the position y_i, where it keeps on moving as normal. \n\n\n\nHow long (from the instant it starts moving) does it take for the ant to reach the position x_n + 1? It can be shown that this happens in a finite amount of time. Since the answer may be very large, compute it modulo 998 244 353.\n\nInput\n\nThe first line contains the integer n (1\u2264 n\u2264 2\u22c5 10^5) \u2014 the number of portals.\n\nThe i-th of the next n lines contains three integers x_i, y_i and s_i (1\u2264 y_i < x_i\u2264 10^9, s_i\u2208\\{0,1\\}) \u2014 the position of the i-th portal, the position where the ant is teleported when it travels through the i-th portal (if it is active), and the initial state of the i-th portal.\n\nThe positions of the portals are strictly increasing, that is x_1<x_2<\u22c5\u22c5\u22c5<x_n. It is guaranteed that the 2n integers x_1,   x_2,   ...,   x_n,   y_1,   y_2,   ...,   y_n are all distinct.\n\nOutput\n\nOutput the amount of time elapsed, in seconds, from the instant the ant starts moving to the instant it reaches the position x_n+1. Since the answer may be very large, output it modulo 998 244 353.\n\nExamples\n\nInput\n\n\n4\n3 2 0\n6 5 1\n7 4 0\n8 1 1\n\n\nOutput\n\n\n23\n\n\nInput\n\n\n1\n454971987 406874902 1\n\n\nOutput\n\n\n503069073\n\n\nInput\n\n\n5\n243385510 42245605 0\n644426565 574769163 0\n708622105 208990040 0\n786625660 616437691 0\n899754846 382774619 0\n\n\nOutput\n\n\n899754847\n\n\nInput\n\n\n5\n200000000 100000000 1\n600000000 400000000 0\n800000000 300000000 0\n900000000 700000000 1\n1000000000 500000000 0\n\n\nOutput\n\n\n3511295\n\nNote\n\nExplanation of the first sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{6}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{3}{\\longrightarrow} 8 \\leadsto 1 \\stackrel{2}{\\longrightarrow} 3 \\leadsto 2 \\stackrel{4}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{2}{\\longrightarrow} 7 \\leadsto 4 \\stackrel{2}{\\longrightarrow} 6 \\leadsto 5 \\stackrel{4}{\\longrightarrow} 9  Notice that the total time is 6+3+2+4+2+2+4=23$$$.\n\nExplanation of the second sample: The ant moves as follows (a curvy arrow denotes a teleporting, a straight arrow denotes normal movement with speed 1 and the time spent during the movement is written above the arrow). $$$ 0 \\stackrel{454971987}{\\longrightarrow} 454971987 \\leadsto 406874902 \\stackrel{48097086}{\\longrightarrow} 454971988  Notice that the total time is 454971987+48097086=503069073$$$.\n\nExplanation of the third sample: Since all portals are initially off, the ant will not be teleported and will go straight from 0 to x_n+1=899754846+1=899754847.\n\n#GENERATED PLAN#:\n",
    "output": [
      "899754847",
      "3511295",
      "23",
      "503069073"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nAlice gave Bob two integers a and b (a > 0 and b \u2265 0). Being a curious boy, Bob wrote down an array of non-negative integers with \\operatorname{MEX} value of all elements equal to a and \\operatorname{XOR} value of all elements equal to b.\n\nWhat is the shortest possible length of the array Bob wrote?\n\nRecall that the \\operatorname{MEX} (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the \\operatorname{XOR} of an array is the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of all the elements of the array.\n\nInput\n\nThe input consists of multiple test cases. The first line contains an integer t (1 \u2264 t \u2264 5 \u22c5 10^4) \u2014 the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers a and b (1 \u2264 a \u2264 3 \u22c5 10^5; 0 \u2264 b \u2264 3 \u22c5 10^5) \u2014 the \\operatorname{MEX} and \\operatorname{XOR} of the array, respectively.\n\nOutput\n\nFor each test case, output one (positive) integer \u2014 the length of the shortest array with \\operatorname{MEX} a and \\operatorname{XOR} b. We can show that such an array always exists.\n\nExample\n\nInput\n\n\n5\n1 1\n2 1\n2 0\n1 10000\n2 10000\n\n\nOutput\n\n\n3\n2\n3\n2\n3\n\nNote\n\nIn the first test case, one of the shortest arrays with \\operatorname{MEX} 1 and \\operatorname{XOR} 1 is [0, 2020, 2021].\n\nIn the second test case, one of the shortest arrays with \\operatorname{MEX} 2 and \\operatorname{XOR} 1 is [0, 1].\n\nIt can be shown that these arrays are the shortest arrays possible.\n\n#GENERATED PLAN#:\n",
    "output": [
      "3\n2\n3\n2\n3\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nConsider the insertion sort algorithm used to sort an integer sequence [a_1, a_2, \u2026, a_n] of length n in non-decreasing order.\n\nFor each i in order from 2 to n, do the following. If a_i \u2265 a_{i-1}, do nothing and move on to the next value of i. Otherwise, find the smallest j such that a_i < a_j, shift the elements on positions from j to i-1 by one position to the right, and write down the initial value of a_i to position j. In this case we'll say that we performed an insertion of an element from position i to position j.\n\nIt can be noticed that after processing any i, the prefix of the sequence [a_1, a_2, \u2026, a_i] is sorted in non-decreasing order, therefore, the algorithm indeed sorts any sequence.\n\nFor example, sorting [4, 5, 3, 1, 3] proceeds as follows: \n\n  * i = 2: a_2 \u2265 a_1, do nothing; \n  * i = 3: j = 1, insert from position 3 to position 1: [3, 4, 5, 1, 3]; \n  * i = 4: j = 1, insert from position 4 to position 1: [1, 3, 4, 5, 3]; \n  * i = 5: j = 3, insert from position 5 to position 3: [1, 3, 3, 4, 5]. \n\n\n\nYou are given an integer n and a list of m integer pairs (x_i, y_i). We are interested in sequences such that if you sort them using the above algorithm, exactly m insertions will be performed: first from position x_1 to position y_1, then from position x_2 to position y_2, ..., finally, from position x_m to position y_m.\n\nHow many sequences of length n consisting of (not necessarily distinct) integers between 1 and n, inclusive, satisfy the above condition? Print this number modulo 998 244 353.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^5). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and m (2 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m < n) \u2014 the length of the sequence and the number of insertions.\n\nThe i-th of the following m lines contains two integers x_i and y_i (2 \u2264 x_1 < x_2 < \u2026 < x_m \u2264 n; 1 \u2264 y_i < x_i). These lines describe the sequence of insertions in chronological order.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 2 \u22c5 10^5. Note that there is no constraint on the sum of n of the same kind.\n\nOutput\n\nFor each test case, print the number of sequences of length n consisting of integers from 1 to n such that sorting them with the described algorithm produces the given sequence of insertions, modulo 998 244 353.\n\nExample\n\nInput\n\n\n3\n3 0\n3 2\n2 1\n3 1\n5 3\n3 1\n4 1\n5 3\n\n\nOutput\n\n\n10\n1\n21\n\nNote\n\nIn the first test case, the algorithm performs no insertions \u2014 therefore, the initial sequence is already sorted in non-decreasing order. There are 10 such sequences: [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3].\n\nIn the second test case, the only sequence satisfying the conditions is [3, 2, 1].\n\nIn the third test case, [4, 5, 3, 1, 3] is one of the sought sequences.\n\n#GENERATED PLAN#:\n",
    "output": [
      "10\n1\n21\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nBritish mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that \"every positive integer was one of his personal friends.\"\n\nIt turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. \n\nDefine a subarray a_i, a_{i+1}, \u2026, a_j to be a friend group if and only if there exists an integer m \u2265 2 such that a_i mod m = a_{i+1} mod m = \u2026 = a_j mod m, where x mod y denotes the remainder when x is divided by y.\n\nYour friend Gregor wants to know the size of the largest friend group in a.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c5 10^4). \n\nEach test case begins with a line containing the integer n (1 \u2264 n \u2264 2 \u22c5 10^5), the size of the array a.\n\nThe next line contains n positive integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.\n\nIt is guaranteed that the sum of n over all test cases is less than 2\u22c5 10^5.\n\nOutput\n\nYour output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.\n\nExample\n\nInput\n\n\n4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 12 45 78\n\n\nOutput\n\n\n3\n3\n2\n6\n\nNote\n\nIn the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.\n\nIn the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.\n\nIn the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.\n\n#GENERATED PLAN#:\n",
    "output": [
      "3\n3\n2\n6\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nYou are given an array a consisting of n distinct elements and an integer k. Each element in the array is a non-negative integer not exceeding 2^k-1.\n\nLet's define the XOR distance for a number x as the value of \n\n$$$f(x) = min_{i = 1}^{n} min_{j = i + 1}^{n} |(a_i \u2295 x) - (a_j \u2295 x)|,$$$\n\nwhere \u2295 denotes [the bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nFor every integer x from 0 to 2^k-1, you have to calculate f(x).\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 k \u2264 19; 2 \u2264 n \u2264 2^k).\n\nThe second line contains n integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 2^k-1). All these integers are distinct.\n\nOutput\n\nPrint 2^k integers. The i-th of them should be equal to f(i-1).\n\nExamples\n\nInput\n\n\n3 3\n6 0 3\n\n\nOutput\n\n\n3 1 1 2 2 1 1 3 \n\n\nInput\n\n\n3 4\n13 4 2\n\n\nOutput\n\n\n2 2 6 6 3 1 2 2 2 2 1 3 6 6 2 2 \n\nNote\n\nConsider the first example:\n\n  * for x = 0, if we apply bitwise XOR to the elements of the array with x, we get the array [6, 0, 3], and the minimum absolute difference of two elements is 3; \n  * for x = 1, if we apply bitwise XOR to the elements of the array with x, we get the array [7, 1, 2], and the minimum absolute difference of two elements is 1; \n  * for x = 2, if we apply bitwise XOR to the elements of the array with x, we get the array [4, 2, 1], and the minimum absolute difference of two elements is 1; \n  * for x = 3, if we apply bitwise XOR to the elements of the array with x, we get the array [5, 3, 0], and the minimum absolute difference of two elements is 2; \n  * for x = 4, if we apply bitwise XOR to the elements of the array with x, we get the array [2, 4, 7], and the minimum absolute difference of two elements is 2; \n  * for x = 5, if we apply bitwise XOR to the elements of the array with x, we get the array [3, 5, 6], and the minimum absolute difference of two elements is 1; \n  * for x = 6, if we apply bitwise XOR to the elements of the array with x, we get the array [0, 6, 5], and the minimum absolute difference of two elements is 1; \n  * for x = 7, if we apply bitwise XOR to the elements of the array with x, we get the array [1, 7, 4], and the minimum absolute difference of two elements is 3. \n\n#GENERATED PLAN#:\n",
    "output": [
      "3 1 1 2 2 1 1 3 ",
      "2 2 6 6 3 1 2 2 2 2 1 3 6 6 2 2 "
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nIvan is playing yet another roguelike computer game. He controls a single hero in the game. The hero has n equipment slots. There is a list of c_i items for the i-th slot, the j-th of them increases the hero strength by a_{i,j}. The items for each slot are pairwise distinct and are listed in the increasing order of their strength increase. So, a_{i,1} < a_{i,2} < ... < a_{i,c_i}.\n\nFor each slot Ivan chooses exactly one item. Let the chosen item for the i-th slot be the b_i-th item in the corresponding list. The sequence of choices [b_1, b_2, ..., b_n] is called a build.\n\nThe strength of a build is the sum of the strength increases of the items in it. Some builds are banned from the game. There is a list of m pairwise distinct banned builds. It's guaranteed that there's at least one build that's not banned.\n\nWhat is the build with the maximum strength that is not banned from the game? If there are multiple builds with maximum strength, print any of them.\n\nInput\n\nThe first line contains a single integer n (1 \u2264 n \u2264 10) \u2014 the number of equipment slots.\n\nThe i-th of the next n lines contains the description of the items for the i-th slot. First, one integer c_i (1 \u2264 c_i \u2264 2 \u22c5 10^5) \u2014 the number of items for the i-th slot. Then c_i integers a_{i,1}, a_{i,2}, ..., a_{i,c_i} (1 \u2264 a_{i,1} < a_{i,2} < ... < a_{i,c_i} \u2264 10^8).\n\nThe sum of c_i doesn't exceed 2 \u22c5 10^5.\n\nThe next line contains a single integer m (0 \u2264 m \u2264 10^5) \u2014 the number of banned builds.\n\nEach of the next m lines contains a description of a banned build \u2014 a sequence of n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 c_i).\n\nThe builds are pairwise distinct, and there's at least one build that's not banned.\n\nOutput\n\nPrint the build with the maximum strength that is not banned from the game. If there are multiple builds with maximum strength, print any of them.\n\nExamples\n\nInput\n\n\n3\n3 1 2 3\n2 1 5\n3 2 4 6\n2\n3 2 3\n3 2 2\n\n\nOutput\n\n\n2 2 3 \n\n\nInput\n\n\n3\n3 1 2 3\n2 1 5\n3 2 4 6\n2\n3 2 3\n2 2 3\n\n\nOutput\n\n\n1 2 3\n\n\nInput\n\n\n3\n3 1 2 3\n2 1 5\n3 2 4 6\n2\n3 2 3\n2 2 3\n\n\nOutput\n\n\n3 2 2\n\n\nInput\n\n\n4\n1 10\n1 4\n1 7\n1 3\n0\n\n\nOutput\n\n\n1 1 1 1 \n\n#GENERATED PLAN#:\n",
    "output": [
      "3 2 2\n",
      "2 2 3\n",
      "1 1 1 1\n",
      "3 2 2\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nThe city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n-1 directed roads in this city. \n\nThere are two kinds of roads:\n\n  * n-1 roads are from village i to village i+1, for all 1\u2264 i \u2264 n-1. \n  * n roads can be described by a sequence a_1,\u2026,a_n. If a_i=0, the i-th of these roads goes from village i to village n+1, otherwise it goes from village n+1 to village i, for all 1\u2264 i\u2264 n. \n\n\n\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \n\nInput\n\nEach test contains multiple test cases. \n\nThe first line contains a single integer t (1 \u2264 t \u2264 20) \u2014 the number of test cases. Each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 indicates that the number of villages is n+1.\n\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1). If a_i=0, it means that there is a road from village i to village n+1. If a_i=1, it means that there is a road from village n+1 to village i.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print -1.\n\nIf there are multiple correct answers, you can print any one of them.\n\nExample\n\nInput\n\n\n2\n3\n0 1 0\n3\n1 1 0\n\n\nOutput\n\n\n1 4 2 3 \n4 1 2 3 \n\nNote\n\nIn the first test case, the city looks like the following graph:\n\n<image>\n\nSo all possible answers are (1 \u2192 4 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4).\n\nIn the second test case, the city looks like the following graph:\n\n<image>\n\nSo all possible answers are (4 \u2192 1 \u2192 2 \u2192 3), (1 \u2192 2 \u2192 3 \u2192 4), (3 \u2192 4 \u2192 1 \u2192 2), (2 \u2192 3 \u2192 4 \u2192 1).\n\n#GENERATED PLAN#:\n",
    "output": [
      "1 2 3 4\n1 2 3 4\n"
    ]
  },
  {
    "input": "You are an AI with advanced code understanding and planning capabilities.\n\nWhen you encounter a specific problem (labeled #PROBLEM#), your goal is to devise a structured and executable plan to solve the problem.\nYour plan should clearly outline the logical steps needed to address the problem, breaking down complex processes into manageable actions.\nIt's crucial that each step is straightforward enough to be easily translated into executable code or functions by a Language Model (LLM).\nKeep the plan simple and focused, avoiding unnecessary complexity to ensure ease of implementation.\n\n#PROBLEM#:\nThe only difference between this problem and D2 is that you don't have to provide the way to construct the answer in this problem, but you have to do it in D2.\n\nThere's a table of n \u00d7 m cells (n rows and m columns). The value of n \u22c5 m is even.\n\nA domino is a figure that consists of two cells having a common side. It may be horizontal (one of the cells is to the right of the other) or vertical (one of the cells is above the other).\n\nYou need to find out whether it is possible to place nm/2 dominoes on the table so that exactly k of them are horizontal and all the other dominoes are vertical. The dominoes cannot overlap and must fill the whole table.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10) \u2014 the number of test cases. Then t test cases follow.\n\nEach test case consists of a single line. The line contains three integers n, m, k (1 \u2264 n,m \u2264 100, 0 \u2264 k \u2264 nm/2, n \u22c5 m is even) \u2014 the number of rows, columns and horizontal dominoes, respectively.\n\nOutput\n\nFor each test case output \"YES\", if it is possible to place dominoes in the desired way, or \"NO\" otherwise.\n\nYou may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\n\nExample\n\nInput\n\n\n8\n4 4 2\n2 3 0\n3 2 3\n1 2 0\n2 4 2\n5 2 2\n2 17 16\n2 1 1\n\n\nOutput\n\n\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\n\n#GENERATED PLAN#:\n",
    "output": [
      "YES\nYES\nYES\nNO\nYES\nNO\nYES\nNO\n"
    ]
  }
]